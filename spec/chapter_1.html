<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 1 - The Dep Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="chapter_1.html" class="active"><strong aria-hidden="true">1.</strong> Chapter 1</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Dep Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Temporary (Pre)Dep Language Specification</p>
<p>This will definitely move, at the very least to a markdown file in the source code.</p>
<p>Right now this is just going to be mostly example code to get this out here</p>
<a class="header" href="#purpose" id="purpose"><h1>Purpose</h1></a>
<p>Dep has one clear goal: if it compiles, it has been proven correct!</p>
<p>The author adds &quot;properties&quot; to methods and classes that specify preconditions, postconditions, and representation invariants. With this information Dep can prove at compile time that all of your code meets these specifications.</p>
<a class="header" href="#hello-world" id="hello-world"><h1>Hello World</h1></a>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<ul>
<li><code>fn</code> starts a function</li>
<li>Curly braces around the function body (C/Java style)</li>
<li>The <code>println!()</code> function is a macro, which is why it ends with a <code>!</code></li>
</ul>
<a class="header" href="#basic-syntax" id="basic-syntax"><h1>Basic Syntax</h1></a>
<a class="header" href="#variables" id="variables"><h2>Variables</h2></a>
<p>In Dep, declare a new variable like so</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
int num = 401;
#}</code></pre></pre>
<p>It contains:</p>
<ul>
<li>Type</li>
<li>Name</li>
<li>Initial value (optional)</li>
</ul>
<p>Dep has the usual primitive types <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code></p>
<p>Primitives all lowercase, but all user defined types including standard library types like <code>String</code> and <code>Vec</code> must use UpperCase</p>
<a class="header" href="#mutability" id="mutability"><h2>Mutability</h2></a>
<p>Variables are immutable by default in Dep. To make them mutable, add the <code>mut</code> keyword</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Vec my_vec = Vec.new();
//my_vec.push(5);
//BAD: my_vec is immutable, push requires a mutable Vec
Vec mut my_mut_vec = Vec.new();
my_mut_vec.push(5);
//OK!
#}</code></pre></pre>
<a class="header" href="#functions" id="functions"><h2>Functions</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sum(int i, int j) -&gt; int {
  return i + j;
}
#}</code></pre></pre>
<p>Return type is denoted after the <code>-&gt;</code> following the function signature. If no return type is specified, this means the function returns nothing.</p>
<a class="header" href="#properties-in-dep" id="properties-in-dep"><h1>Properties in Dep</h1></a>
<a class="header" href="#zero-cost-abstraction" id="zero-cost-abstraction"><h2>Zero-Cost Abstraction</h2></a>
<p>In Dep, you can guarantee the correctness of your code without ever sacrificing speed. Just like how the type system in C/C++ has effect on speed, properties in Dep are only checked at compile-time.</p>
<p>This is the core principle of Dep:</p>
<blockquote>
<p>Prove your programs correct with zero-cost abstractions</p>
</blockquote>
<a class="header" href="#function-contracts" id="function-contracts"><h2>Function Contracts</h2></a>
<p>You can specify a <a href="https://en.wikipedia.org/wiki/Precondition">precondition</a> and <a href="https://en.wikipedia.org/wiki/Postcondition">postcondition</a> in the method signature itself! Start with this function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sum(i32 left, i32 right) -&gt; i32 {
  return left + right;
}
#}</code></pre></pre>
<p>We can define what about the result will always be true (AKA the postcondition). This is just a change to the method signature by adding a &quot;property&quot; to the return value. See that <code>: Sum(a,b)</code> after the return type? In this case, <code>Sum(a,b)</code> is a built-in property that means that this value (the one being returned) must be equivalent to the sum of its two arguments</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sum(i32 a, i32 b) -&gt; i32 : Sum(a,b) {
//                          ^^^^^^^^^^
  return a + b;
}
#}</code></pre></pre>
<a class="header" href="#the--colon-in-dep" id="the--colon-in-dep"><h2>The <code>:</code> (Colon) in Dep</h2></a>
<p>In Dep, the colon has one, and only one, meaning:</p>
<pre><code class="language-quote">The properties after the colon describe the variable before the colon
</code></pre>
<a class="header" href="#making-our-own-properties" id="making-our-own-properties"><h2>Making Our Own Properties</h2></a>
<p>That's trivial, let's try something a little more interesting. Scaling by a random number &gt; 1</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn scaleUpRand(i32 in) -&gt; i32 {
  return in * rand(2, 100);
}
#}</code></pre></pre>
<p>Let's say we want to know that our number increased as a result of this operation</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
prop Bigger(i32 self, i32 other) {
  self &gt; other
}
#}</code></pre></pre>
<p>Now we can embed this property into our method signature like before</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn scaleUpRand(i32 in) -&gt; i32 : Bigger(in) {
  return in * rand(2, 100);
}
#}</code></pre></pre>
<p>Note, the compiler can recognize that because the minimum value that <code>rand(2,100)</code> returns is 2, then then minimum value returned is <code>in*2</code>. Because <code>in*2 &gt; in</code>, it can guarantee at compile time that the return value is bigger than the input!</p>
<p>You may also be saying, &quot;Wait, I thought Bigger takes two arguments, you only gave one...&quot;. When we defined <code>Bigger</code> the first argument was named <code>self</code> which is a special keyword making this property like a method, it infers the first argument is the value it is being defined for (e.g. the return value)</p>
<a class="header" href="#using-properties-on-local-variables" id="using-properties-on-local-variables"><h2>Using Properties on Local Variables</h2></a>
<p>Properties can also be applied to normal variable decalarations</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
int mut i = 5;
int mut j : Bigger(i) = 10;
//^^ OK
j = 15;
//^^ Still OK
//j = 0;
//^^ Causes compile time error, j defies type property Bigger(i)
#}</code></pre></pre>
<p>Note that the property doesn't just have to hold true initially, it must always hold true. If the compiler cannot guarantee that all properties are true, then it will not compile.</p>
<a class="header" href="#multiple-properties" id="multiple-properties"><h2>Multiple Properties</h2></a>
<p>Variables can have as many properties as you want. When defining multiple properties, put a <code>+</code> between the properties</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
int i : Bigger(5) + Not(10) = 7;
#}</code></pre></pre>
<p>We use the <code>+</code> symbol here instead of something like <code>,</code> because it would make parsing difficult in some situations. For example, using generics.</p>
<a class="header" href="#property-debugging-with-the-hash-symbol-" id="property-debugging-with-the-hash-symbol-"><h2>Property Debugging with the Hash Symbol (<code>#</code>)</h2></a>
<p>You've heard of <code>println</code> debugging, where you print out values at certain points in the code to test your understanding of what the code is doing.</p>
<p>However, in Dep because properties must work together, it's also important to test your understanding of the compile-time guarantees that the compiler can infer. By putting a property after the pound symbol, the compile will tell you whether that property holds. This is essentially compile-time assertions</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
int i = 5;
# i &gt; 0
int my_rand = rand(100) * 2;
# my_rand : Even
#}</code></pre></pre>
<p>The compiler will show that all of these can be proven true at compile-time.</p>
<a class="header" href="#on-compiler--hash-assert-interaction" id="on-compiler--hash-assert-interaction"><h3>On Compiler &amp; Hash Assert Interaction</h3></a>
<p>Although hash asserts will never change your code, they <em>can</em> help the compiler. It is non-trivial for the compiler to infer the needed properties to prove your code correct, and you hash asserts can serve as sort of a hint for what properties the compiler should be keeping track of...</p>
<p>Or not, I'm still getting to that part of the compiler. It defintely helps the humans who read your code, though :)</p>
<a class="header" href="#the-power-of-contracts" id="the-power-of-contracts"><h1>The Power of Contracts</h1></a>
<p>Let's write quicksort. Just by compiling in Dep, it will be proven that this function is a correct implementation of a sorting function. We do this by creating a contract in the function</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn q_sort(Vec&lt;int&gt; src) -&gt; Vec&lt;int&gt; : Sorted + Reorder(src) { ... }
#}</code></pre></pre>
<p>Let's break down just the method signature.</p>
<p>First, it takes in a vector (resizing array) of ints and returns a vector of ints.</p>
<p>Next, after the return type we see the colon, signaling a list of properties about the return.</p>
<p>There are two properties of the return type, <code>Sorted</code> and <code>Reorder(in)</code></p>
<a class="header" href="#sorted-property" id="sorted-property"><h2><code>Sorted</code> Property</h2></a>
<p>The Sorted property's definition looks like so</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
prop Sorted(Vec&lt;int&gt; self) {
  forall (e,f) in self.AdjPair(): e &lt; f
}
#}</code></pre></pre>
<p>The way we can read this is &quot;Sorted is a property of Vec<int>, where for every e &amp; f adjacent to each other, e is less than f&quot;</p>
<p>You may be saying, &quot;hold on, you said that no runtime code is executed by properties, but this one has a for loop!&quot; You are correct that there is a for loop, however, there are two key differences.</p>
<p>The loop is using <code>forall</code> which is proving an expression (<code>e&lt;f</code>) holds for every <code>(e,f)</code> in this Vec. It never actually generates any code, the compiler simply verifies that, in this case, any adjacent pair will be sorted.</p>
<p>Similar idea, The function returning an iterator in this case is <code>self.AdjPair()</code>. Notice the UpperCase on the method. This means that the method is also a property! These &quot;property functions&quot; also never generate any code, <code>AdjPair()</code> simply returns an expression describing every adjacent pair in this Vec. No iterator is generated at runtime.</p>
<a class="header" href="#reordervec-property" id="reordervec-property"><h2><code>Reorder(Vec)</code> Property</h2></a>
<p>The other property of the return value is <code>Reorder(src)</code>. What this means is that all of the elements in <code>src</code> are also in the output, but not necessarily in the same order.</p>
<p>This is important because we need to know that the function doesn't discard any values in the original input.</p>
<a class="header" href="#quicksort-implementation" id="quicksort-implementation"><h2>Quicksort Implementation</h2></a>
<p>In case you don't know how quicksort works or forgot, here's a quick refresher. Note this is not the in-place quicksort, so it will allocate more memory. <em>However</em>, in-place quicksort is entirely possible and proveable in Dep, we may revisit it later to show properties that work on systems-style applications</p>
<p>The pseudocode for Quicksort goes like</p>
<pre><code>fn quicksort(src) -&gt; out {
  # Base case: one or zero element array is already sorted
  if (src.len &lt; 2) 
    return src
  pivot = random element from src
  left = new array
  right = new array
  # Split the input into values less than pivot and greater than pivot
  foreach curr in src {
    if (curr &lt; pivot)
      left.push(curr)
    else
      right.push(curr)
  }
  # Sort each half recursively
  left = quicksort(left)
  right = quicksort(right)
  # Since left &amp; right are sorted, put right on the end of left
  return left.push(right)
}
</code></pre>
<p>The Dep version will look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn q_sort(Vec src) -&gt; Vec : Sorted + Reorder(src) {
  if (src.len &lt; 2)
    return src;
  int pivot = src.getRand();
  Vec left = Vec.new();
  Vec right = Vec.new();
  for (int curr in src) {
    if (curr &lt; pivot) 
      left.push(curr);
    else 
      right.push(curr);
  }
  left = q_sort(left);
  right = q_sort(right);
  return left.push(right);
}
#}</code></pre></pre>
<p>The great thing is that this looks almost exactly like our pseudocode! The only difference was the properties of the return value which we discussed earlier. Despite the fact that we just translated our pseudocode, this is all proven correct at compile-time!</p>
<p>This is all thanks to the property definitions of the standard library which accounts for <code>Vec</code> and <code>Vec.push</code> as well as several other implicit properties which the compiler can compose together to get our return value's properties</p>
<p>In the next section we will talk about some of these</p>
<a class="header" href="#lt-and-geq" id="lt-and-geq"><h1><code>Lt()</code> and <code>Geq()</code></h1></a>
<p>These properties stand for &quot;less than&quot; and &quot;greater than or equal to&quot; respectively. The compiler automatically infers these properties to verify the postcondition.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn Lt(Vec self, int ceil) {
  forall e in self: e &lt; ceil
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn Geq(Vec self, int floor) {
  forall e in self: e &gt;= floor
}
#}</code></pre></pre>
<p>These properties can be applied to prove that all the elements are less than or greater than/equal to a certain value. In this case, we are concerned with the pivot.</p>
<p>In the for loop we can verify these properties as the loop invariant</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for (int curr in src) { # left : Lt(pivot) &amp;&amp; right : Geq(pivot)
    if (curr &lt; pivot) 
        left.push(curr);
    else 
        right.push(curr);
}
#}</code></pre></pre>
<p>If we add these compile-time asserts to our code it will still compile because the compiler can infer that at any iteration of this loop, these two properties will hold</p>
<p>For example, we know that at the start of the first iteration of the loop, left will be empty, meaning that all of the elements in it are less than the pivot (since there are none).</p>
<p>It gets more interesting when we realize that the compiler has infered that because <code>left</code> is only modified in one branch of the if statement, it can make stronger assumptions about how <code>left</code> is being modified. And indeed, <code>left</code> will only ever be modified by pushing elements less than the pivot onto the end of it.</p>
<p>Applying the same logic we can see how <code>Geq()</code> was applied</p>
<a class="header" href="#property-functions" id="property-functions"><h2>Property Functions</h2></a>
<a class="header" href="#adjpair" id="adjpair"><h2><code>AdjPair()</code></h2></a>
<p>In the quicksort example, we used the property <code>Sorted</code> whose definition includes this operation on a  <code>Vec</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.AdjPair()
#}</code></pre></pre>
<p>This is a property function, like properties it generates no run-time code and uses UpperCase.</p>
<p><code>AdjPair</code> describes every adjacent pair in a vector, let's look at its definition</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
prop fn AdjPair(Vec self) -&gt; prop Iter&lt;(int, int)&gt; {
//                           ^^^^ not necessary, but nice if you want to be explicit
  forall i in 0..self.len-2: (self.arr[i], self.arr[i+1])
}
#}</code></pre></pre>
<p>This property function returns a &quot;property iterator&quot; over the adjacent pairs in <code>self</code>. The <code>prop</code> keyword in the return type indicates that this value will never be created at run-time. <code>prop</code> values can only be returned by <code>prop</code> functions, and because of this, the <code>prop</code> in the return type is optional, but we use it to differentiate between a real, run-time iterator and a property iterator that simply represents an expression to the compiler.</p>
<p>Again, we use the <code>forall</code> syntax to make an expression, this time representing values instead of just boolean expressions. Specifically, we are creating a set of tuples, where each one represents an adjacent pair in the <code>self</code> internal array.</p>
<a class="header" href="#property-types" id="property-types"><h2>Property Types</h2></a>
<p>The <code>prop Iter</code> from the last section is one of actually only a handful of these property types. Because property types are only ever needed at compile-time they work closely with the language and cannot be extended by the user.</p>
<a class="header" href="#reordervec" id="reordervec"><h2><code>Reorder(Vec)</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
prop Reorder(Vec self, Vec src) {
  forall e in self: e in src,
  forall e in src: e in self
}
#}</code></pre></pre>
<a class="header" href="#the-in-keyword" id="the-in-keyword"><h1>The <code>in</code> keyword</h1></a>
<p>In Dep, the <code>in</code> keyword can be used both in runtime <code>for</code> loops and compile-time <code>forall</code> expressions</p>
<p>They both call functions which can be overridden. <code>iter()</code> for <code>for</code> loops and <code>propIter()</code> for <code>forall</code> expressions</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn iter(Vec self) -&gt; Iter&lt;int&gt;;
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
prop fn propIter(Vec self) -&gt; prop Iter&lt;int&gt; {
  forall i in self.len-1: self.arr[i]
}
#}</code></pre></pre>
<a class="header" href="#memory-management" id="memory-management"><h1>Memory Management</h1></a>
<p>This section is very volatile, and not fully decided. However, I'd like to present my tentative idea</p>
<a class="header" href="#non-nullable--nullable-types" id="non-nullable--nullable-types"><h2>Non-Nullable &amp; Nullable Types</h2></a>
<p>By default, when you declare a variable with a non-primitive type, like <code>String</code> as shown here...</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
String s = &quot;Hello&quot;;
Vec v = Vec.new();
#}</code></pre></pre>
<p>In this situation, the Type identifier on the far left was just the type name. This means that you have defined a non-nullable reference, like in Swift.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//String s = null;
//BAD: s is non-nullable
#}</code></pre></pre>
<p>Also as in Swift, null-able data types can be declared using a <code>?</code> after the type name</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
String? s = null;
//OK!
#}</code></pre></pre>
<p>This means that if your function might return null, the return type must be nullable</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mightBeNull() -&gt; String? {
  if (rand(100) == 0)
    null;
  else
    &quot;roll again...&quot;;
}
#}</code></pre></pre>
<p>And if you have a non-nullable data type, it cannot take nullable data</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//String s = mightBeNull();
//BAD: mightBeNull returns a nullable String
#}</code></pre></pre>
<p>Here we can use the reduced ternary operator (<code>?:</code>) AKA the Elvis operator to return early if this <code>mightBeNull()</code> is <code>null</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
String s = mightBeNull() ?: return;
#}</code></pre></pre>
<a class="header" href="#owned-types" id="owned-types"><h2>Owned Types</h2></a>
<p>However, we would like introduce the concept of ownership similar to in Rust. This provides a benefit not only in the efficiency of your code, but also in its structure.</p>
<p>I'm imagining something like</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Vec own my_vec = Vec.own();
#}</code></pre></pre>
<p>Where the <code>Vec.own()</code> method returns a new owned reference to a <code>Vec</code>. You could also get a reference like</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Vec own my_vec = Vec.own();
Vec ref borrow = ref my_vec;
#}</code></pre></pre>
<p>I also had another idea where there is a shortened syntax for both of these</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Vec$ owned_vec = Vec.own();
Vec&amp; borrow = &amp;owned_vec;
#}</code></pre></pre>
<a class="header" href="#pre-dep-vs-dep" id="pre-dep-vs-dep"><h1>Pre-Dep vs Dep</h1></a>
<p>What's the whole deal with this Pre-Dep business? Basically, I'm not 100% set on the semantics and syntax of the language, and some things are so in-flux that I'm not confident I can describe a &quot;beta&quot; form of the language and then just make small changes. More like I need to make an &quot;alpha&quot; of the language (Pre-Dep) , and then decide for real on some of the semantics which will get finalized and become the Dep language.</p>
<p>I chose the name Pre-Dep because in my opinion it's easier to describe the earlier state of a language using a different name than version number like Python 2 vs 3</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
